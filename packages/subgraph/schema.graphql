type TenderizeGlobal @entity { # Global Values/ TODO: better name?
  "Fixed ID of '1'"
  id: ID!
  "List of congifs for all integrations"
  configs: [ProtocolConfig!]!
  # TODO: Add global totals 
}

type ProtocolConfig @entity {
  "ID: Name of the protocol eg. 'livepeer'"
  id: ID!
  "Address of the ERC20 token for integration"
  steak: String!
  "Address of Tenderizer"
  tenderizer: String!
  "Address of ERC20 Tender Token"
  tenderToken: String!
  "Address of Elastic Supply Pool"
  esp: String!
  "Address of liquidity pool for pair"
  bpool: String!
  "Address of TenderFarm contract"
  tenderFarm: String!
}

type Protocol @entity {
  "Name of the protocol eg. 'livepeer'"
  id: ID!
  "Tenderizer Data"
  tenderizer: Tenderizer @derivedFrom(field: "protocol")
  "TenderFarm Data"
  tenderFarm: TenderFarm @derivedFrom(field: "protocol")
  "Paritcipating user list"
  users: [UserProtocol!] @derivedFrom(field: "protocol")
  "Count of users participated in Protocol"
  userCount: BigInt!
}

type Tenderizer @entity {
  "Name of the protocol eg. 'livepeer'"
  id: ID!
  "Protocol entity"
  protocol: Protocol!

  "Total amount depositied in tenderizer"
  deposits: BigDecimal!
  "Total number of tenderizer depostis"
  depositCount: BigInt!
  "Total amount withdrawn from tenderizer"
  withdrawals: BigDecimal!
  "Total number of tenderizer withdrawals"
  withdrawalCount: BigInt!
  "Total rewards collected from protocol"
  rewards: BigDecimal!
  "Total number of times rewards were collected"
  rewardCount: BigInt!
  "Total depsotis + total rewards - total withdrawals"
  currentPrincipal: BigDecimal!

  "Total amount of protocol fees collected from tenderizer"
  protocolFees: BigDecimal!
  "Total amount of liquidity fees collected from tenderizer"
  liquidityFees: BigDecimal!

  "Day data for tenderizer"
  dayData: [TenderizerDay!]! @derivedFrom(field: "tenderizer")
}

type TenderFarm @entity {
  "Name of the protocol eg. 'livepeer'"
  id: ID!
  "Protocol"
  protocol: Protocol!

  "Total deposits made into farm"
  deposits: BigDecimal!
  "Total number of depostits made"
  depositCount: BigInt!
  "Total withrawals made from farm"
  withdrawals: BigDecimal!
  "Total number of withdrawals made"
  withdrawalCount: BigInt!
  "Total rewards collected from farm"
  harvest: BigDecimal!
  "Total number of harvests made"
  harvestCount: BigInt!
  "Total depsotis - total withdrawals"
  currentPrincipal: BigDecimal!

  "Day data for tenderFarm"
  dayData: [TenderFarmDay!]! @derivedFrom(field: "tenderFarm")
}

type TenderizerDay @entity {
  "<Timestamp rounded to current day by dividing by 86400>_<portocol>"
  id: ID!
  "Name of the protocol eg. 'livepeer'"
  protocolName: String!
  "Tenderizer"
  tenderizer: Tenderizer!
  "The date beginning at 12:00am UTC"
  date: Int!

  "deposits volume in tenderizer for the day"
  deposits: BigDecimal!
  "withdraw volume in tenderizer for the day"
  withdrawals: BigDecimal!
  "Total volume for the day: deposits - withdrawals"
  volume: BigDecimal!
  "cumulative deposit on that day"
  cumulativeVolume: BigDecimal!

  "staking rewards collected from protocol for the day"
  rewards: BigDecimal!
  "cumulative staking rewards collected"
  cumulativeRewards: BigDecimal!
}

type TenderFarmDay @entity {
  "<Timestamp rounded to current day by dividing by 86400>_<portocol>"
  id: ID!
  "Name of the protocol eg. 'livepeer'"
  protocolName: String!
  "TenderFarm"
  tenderFarm: TenderFarm!
  "The date beginning at 12:00am UTC"
  date: Int!

  "farm volume for the day"
  deposits: BigDecimal!
  "unfarm volume for the day"
  withdrawals: BigDecimal!
  "Total volume for the day: farm - unfarm"
  volume: BigDecimal!
  "cumulative farm on that day"
  cumulativeVolume: BigDecimal! 

  "harvest volume for the day"
  harvest: BigDecimal!
  "cumulative harvest on that day"
  cumulatinveHarvest: BigDecimal!
}

type User @entity {
  "Wallet address of user"
  id: ID!
  "Data for each integration per user"
  protocols: [UserProtocol!]! @derivedFrom(field: "user")
}

type UserProtocol @entity { 
  "<wallet-address>_<portocol>"
  id: ID!
  "Name of the protocol eg. 'livepeer'"
  protocolName: String!
  "Protocol"
  protocol: Protocol!
  "User"
  user: User!
  "Tenderizer data for user"
  tenderizer: UserTenderizer @derivedFrom(field: "userProtocol")
  "TenderFarm data for user"
  tenderFarm: UserTenderFarm @derivedFrom(field: "userProtocol")
}

type UserTenderizer @entity {
  "ID: <wallet-address>_<portocol>"
  id: ID!
  "User-Protocol"
  userProtocol: UserProtocol!
  "Total amount depositied in tenderizer by given user"
  deposits: BigDecimal!
  "Total amount depositied in tenderizer by given user"
  withdrawals: BigDecimal!
}

type UserTenderFarm @entity {
  "ID: <wallet-address>_<portocol>"
  id: ID!
  "User-Protocol"
  userProtocol: UserProtocol!
  "Total amount depositied in farm by given user"
  deposits: BigDecimal!
  "Total amount withdrawn from farm by given user"
  withdrawals: BigDecimal!
  "Total amount harvest collected from farm by given user"
  harvest: BigDecimal!
}

# Registry event entity
type TenderizerCreatedEvent @entity {
  id: ID!
  name: String!
  steak: String!
  tenderizer: String!
  tenderToken: String!
  esp: String!
  bpool: String!
  tenderFarm: String!
  timestamp: BigInt!
}

# Tenderizer Event entities
type DepositEvent @entity {
  id: ID!
  tenderizer: String!
  from: String!
  amount: BigInt!
  timestamp: BigInt!
}

type StakeEvent @entity {
  id: ID!
  tenderizer: String!
  node: String!
  amount: BigInt!
  timestamp: BigInt!
}

type UnstakeEvent @entity {
  id: ID!
  tenderizer: String!
  from: String!
  node: String!
  amount: BigInt!
  timestamp: BigInt!
}

type WithdrawEvent @entity {
  id: ID!
  tenderizer: String!
  from: String!
  amount: BigInt!
  timestamp: BigInt!
}

type RewardsClaimedEvent @entity {
  id: ID!
  tenderizer: String!
  rewards: BigInt!
  currentPrincipal: BigInt!
  timestamp: BigInt!
}

type ProtocolFeeCollectedEvent @entity {
  id: ID!
  tenderizer: String!
  amount: BigInt!
  timestamp: BigInt!
}

type LiquidityFeeCollectedEvent @entity {
  id: ID!
  tenderizer: String!
  amount: BigInt!
  timestamp: BigInt!
}

# TenderFarm Event entities
type FarmEvent @entity {
  id: ID!
  tenderFarm: String!
  from: String!
  amount: BigInt!
  timestamp: BigInt!
}

type UnfarmEvent @entity {
  id: ID!
  tenderFarm: String!
  from: String!
  amount: BigInt!
  timestamp: BigInt!
}

type HarvestEvent @entity {
  id: ID!
  tenderFarm: String!
  from: String!
  amount: BigInt!
  timestamp: BigInt!
}


# Pool Entities
type Balancer @entity {
    id: ID!
    color: String!                                      # Bronze, Silver, Gold
    poolCount: Int!                                     # Number of pools
    finalizedPoolCount: Int!                            # Number of finalized pools
    crpCount: Int!                                      # Number of CRP
    # pools: [Pool!] @derivedFrom(field: "factoryID")
    txCount: BigInt!                                    # Number of txs
    totalLiquidity: BigDecimal!                         # All the pools liquidity value in USD
    totalSwapVolume: BigDecimal!                        # All the swap volume in USD
    totalSwapFee: BigDecimal!                           # All the swap fee in USD
}

type Pool @entity {
    id: ID!                                             # Pool address
    controller: Bytes                                   # Controller address
    publicSwap: Boolean!                                # isPublicSwap
    finalized: Boolean!                                 # isFinalized
    crp: Boolean!                                       # Is configurable rights pool
    crpController: Bytes                                # CRP controller address
    symbol: String                                      # Pool token symbol
    name: String                                        # Pool token name
    rights: [String!]!                                  # List of rights (for CRP)
    cap: BigInt                                         # Maximum supply if any (for CRP)
    active: Boolean!                                    # isActive
    swapFee: BigDecimal!                                # Swap Fees
    totalWeight: BigDecimal!
    totalShares: BigDecimal!                            # Total pool token shares
    totalSwapVolume: BigDecimal!                        # Total swap volume in USD
    totalSwapFee: BigDecimal!                           # Total swap fee in USD
    liquidity: BigDecimal!                              # Pool liquidity value in USD
    tokensList: [Bytes!]!                               # Temp workaround until graph supports filtering on derived field
    tokens: [PoolToken!] @derivedFrom(field: "poolId")
    shares: [PoolShare!] @derivedFrom(field: "poolId")
    # createTime: Int!                                    # Block time pool was created
    tokensCount: BigInt!                                # Number of tokens in the pool
    holdersCount: BigInt!                               # Number of addresses holding a positive balance of BPT
    joinsCount: BigInt!                                 # liquidity has been added
    exitsCount: BigInt!                                 # liquidity has been removed
    swapsCount: BigInt!
    # factoryID: Balancer!
    # tx: Bytes                                           # Pool creation transaction id
    swaps: [Swap!] @derivedFrom(field: "poolAddress")
}

type PoolToken @entity {
    id: ID!                                             # poolId + token address
    poolId: Pool!
    symbol: String
    name: String
    decimals: Int!
    address: String!
    balance: BigDecimal!
    denormWeight: BigDecimal!
}

type PoolShare @entity {
    id: ID!                                             # poolId + userAddress
    userAddress: User!
    poolId: Pool!
    balance: BigDecimal!
}

# type User @entity {
#     id: ID!
#     sharesOwned: [PoolShare!]  @derivedFrom(field: "userAddress")
#     txs: [Transaction!]  @derivedFrom(field: "userAddress")
#     swaps: [Swap!]  @derivedFrom(field: "userAddress")
# }

type Swap @entity {
    id: ID!                                 #
    caller: Bytes!                          #
    tokenIn: Bytes!                         #
    tokenInSym: String!                     #
    tokenOut: Bytes!                        #
    tokenOutSym: String!                    #
    tokenAmountIn: BigDecimal!              #
    tokenAmountOut: BigDecimal!             #
    poolAddress: Pool
    userAddress: User                       # User address that initiates the swap
    value: BigDecimal!                      # Swap value in USD
    feeValue: BigDecimal!                   # Swap fee value in USD
    poolTotalSwapVolume: BigDecimal!        # Total pool swap volume in USD
    poolTotalSwapFee: BigDecimal!           # Total pool swap fee in USD
    poolLiquidity: BigDecimal!              # Pool liquidity value in USD
    timestamp: Int!
}

type Transaction @entity {
    id: ID!                         # Log ID
    tx: Bytes!
    event: String
    block: Int!
    timestamp: Int!
    gasUsed: BigDecimal!
    gasPrice: BigDecimal!
    poolAddress: Pool
    userAddress: User
    action: SwapType
    sender: Bytes
}

type TokenPrice @entity {
    id: ID!
    symbol: String
    name: String
    decimals: Int!
    price: BigDecimal!
    poolLiquidity: BigDecimal!
    poolTokenId: String
}

enum SwapType {
    swapExactAmountIn,
    swapExactAmountOut,
    joinswapExternAmountIn,
    joinswapPoolAmountOut,
    exitswapPoolAmountIn,
    exitswapExternAmountOut
}